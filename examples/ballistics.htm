<html>
  <head>
    <title>Ballistics</title>
    <link 
      rel="stylesheet" 
      href="bower_components/bootstrap/dist/css/bootstrap.min.css" />
    <style>
      .main {
        width: 600px;
        padding:10px;
        margin:30px auto;
        border:1px solid #ccc;
        border-radius:4px;
      }

      /* TODO: Scope to SVG */
      .axis path,
      .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }
      .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 1.5px;
      }
    </style>
  </head>
  <body>


    <div class="main container">
      <div class="form-horizontal" role="form">
        <div class="form-group">
          <label for="g" class="col-sm-3 control-label">
            G (m/s<sup>2</sup>)
          </label>
          <div class="col-sm-9">
            <input 
              id="g" 
              value="9.81" 
              class="form-control" 
              type="number" 
              step="any"
              min="1" />
          </div>
        </div>
        <div class="form-group">
          <label for="theta" class="col-sm-3 control-label">
            &Theta; (Degrees)
          </label>
          <div class="col-sm-9">
            <input 
              id="theta" 
              value="45" 
              class="form-control" 
              type="number" 
              step="0.5"
              max="89.5"
              min="0.5" />
          </div>
        </div>
        <div class="form-group">
          <label for="v" class="col-sm-3 control-label">
            v (m/s)
          </label>
          <div class="col-sm-9">
            <input 
              id="v" 
              class="form-control" 
              value="10" 
              type="number" 
              step="any" 
              min="1" />
          </div>
        </div>
        <div class="form-group">
          <label for="y_0" class="col-sm-3 control-label">
            y<sub>0</sub> (m)
          </label>
          <div class="col-sm-9">
            <input
              id="y_0"
              value="10"
              class="form-control"
              type="number" 
              step="any"
              min="0"
              max="100" />
          </div>
        </div>
        <div class="form-group">
          <label for="d" class="col-sm-3 control-label">
            d (m)
          </label>
          <div class="col-sm-9">
            <p id="d" class="form-control-static"></p>
          </div>
        </div>
        <div class="form-group">
          <label for="v_f" class="col-sm-3 control-label">
            v<sub>f</sub> (m/s)
          </label>
          <div class="col-sm-9">
            <p id="v_f" class="form-control-static"></p>
          </div>
        </div>
      </div>
    </div>

     


    <script src="../cable.min.js"></script>
    <script>
      // http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
      var Ballistics = {
        d:function(g, theta, v, y_0) {
          return (
            (v * Math.cos(theta) / g) * (
              (v * Math.sin(theta)) +
              Math.sqrt(
                Math.pow(v * Math.sin(theta), 2) + 
                (2 * g * y_0)
              )
            )
          );
        },
        t:function(g, theta, v, y_0) {
          return (
            (
              (v * Math.sin(theta)) +
              Math.sqrt(
                Math.pow(v * Math.sin(theta), 2) + 
                (2 * g * y_0)
              )
            ) /
            g
          );
        },
        phi:function(g, d, v) {
          return (
            0.5 *
            Math.asin(
              (g * d) / 
              (v * v)
            )
          );
        },
        h:function(g, theta, v, y_0, x) {
          return (
            y_0 + (x * Math.tan(theta)) - 
            (
              (g * x * x) /
              (2 * Math.pow(v * Math.cos(theta), 2))
            )
          );
        },
        v:function(g, theta, v, y_0, x) {
          return Math.sqrt(
            (v * v) -
            (2 * g * x * Math.tan(theta)) +
            Math.pow(
              (g * x) / 
              (v * Math.cos(theta)),
              2
            )
          );
        },

        trajectory:function(g, theta, v, y_0, n) {
          var 
            dx = this.d(g, theta, v, y_0) / n,
            result = [];

          for (var idx = 0; idx <= n; ++idx) {
            result.push({
              x:dx * idx,
              h:this.h(g, theta, v, y_0, dx * idx),
              v:this.v(g, theta, v, y_0, dx * idx),
            });
          }

          return result;
        }
      };

      var Plot = {
        slices:20,

        setup:function(d3) {
          var
            margin = {top: 20, right: 30, bottom: 30, left: 150},
            width = 578 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom,

            x = d3.scale.linear().range([0, width]),
            y = d3.scale.linear().range([height, 0]),
            v = d3.scale.linear().range([0,255])

            xAxis = d3.svg.axis()
              .scale(x)
              .orient("bottom"),
            yAxis = d3.svg.axis()
              .scale(y)
              .orient("left"),
            svg = d3.select(".main")
              .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr(
                  "transform", 
                  "translate(" + margin.left + "," + margin.top + ")"
                );

          x.domain([0,10000]);
          y.domain([0,100]);

          var
            gx = svg.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + height + ")")
              .call(xAxis),
            gy = svg.append("g")
              .attr("class", "y axis")
              .call(yAxis);

          var markers = svg.append("g")
            .attr("class", "markers");

          svg.append("defs").append("marker")
            .attr({
              id:"arrowhead",
              refX:5,
              refY:2.5,
              markerWidth:10,
              markerHeight:20,
              orient:"auto",
              style:"fill:none;stroke-width:1;stroke:#666;"
            })
            .append("path")
            .attr("d", "M 0,0 L 5,2.5 L0,6");

          return {
            scale:{ x:x, y:y, v:v },
            axis:{ x:xAxis, gx:gx, y:yAxis, gy:gy },
            svg:svg,
            markers:markers
          };
        },

        updateScale:function(d3, plot, region, traj) {
          var 
            x_ext = d3.extent(traj, function(d) { return d.x; }),
            y_ext = d3.extent(traj, function(d) { return d.h; }),
            scale = Math.max(x_ext[1], y_ext[1]);

          if (scale > region) {
            region = 1.5 * scale;
          }
          else if (1.5 * scale < region) {
            region = scale;
          }

          plot.scale.x.domain([0, region]);
          plot.scale.y.domain([0, region]);
          plot.scale.v.domain(d3.extent(traj, function(d) { return d.v; }));

          plot.axis.x.scale(plot.scale.x);
          plot.axis.y.scale(plot.scale.y);

          plot.axis.gx.transition().call(plot.axis.x);
          plot.axis.gy.transition().call(plot.axis.y);

          return region;
        },

        updateTrajectory:function(d3, plot, markers) {
          var lines = plot.svg.selectAll(".marker")
            .data(markers);

          lines.enter()
            .append("line")
            .attr("class", "marker");

          lines
            .transition()
            .attr({
              x1:function(d) { return plot.scale.x(d.x1); },
              y1:function(d) { return plot.scale.y(d.y1); },
              x2:function(d) { return plot.scale.x(d.x2); },
              y2:function(d) { return plot.scale.y(d.y2); }
            });

          lines
            .attr({
              style:function(d) { 
                return (
                  "stroke-width:2;" + 
                  "marker-end:url(#arrowhead);" +
                  "stroke:rgb(" + 
                    Math.floor(plot.scale.v(d.v)) + 
                    ",0," + 
                    Math.floor(255 - plot.scale.v(d.v)) + 
                  ");"
                );
              }
            });

          lines.exit().remove();
        },

        update:function(d3, plot, region, g, theta, v, y_0) {

          var
            traj = Ballistics.trajectory(g, theta, v, y_0, this.slices),
            markers = [];

          for (var idx = 0; idx < traj.length - 1; ++idx) {
            markers.push({ 
              x1:traj[idx].x,
              y1:traj[idx].h,
              x2:traj[idx + 1].x,
              y2:traj[idx + 1].h,
              v:traj[idx].v
            });
          }

          var newRegion = this.updateScale(d3, plot, region, traj);
          this.updateTrajectory(d3, plot, markers);

          return newRegion
        }
      };


      Cable.define({
        $:Cable.library("bower_components/jquery/dist/jquery.min.js"),
        
        d3:Cable.library("bower_components/d3/d3.min.js"),

        plot:Cable.data(null),
        region:Cable.data(0),
        
        g:          Cable.textbox("#g"),
        theta_deg:  Cable.textbox("#theta"),
        v:          Cable.textbox("#v"),
        y_0:        Cable.textbox("#y_0"),

        theta:function(theta_deg, result) { 
          result(theta_deg() * (Math.PI / 180)); 
        },

        d:function(g, theta, v, y_0, result) {
          result(Ballistics.d(g(), theta(), v(), y_0()));
        },

        v_f:function(g, theta, v, y_0, d, result) {
          result(Ballistics.v(g(), theta(), v(), y_0(), d()));
        },

        showD:Cable.template("#d", "{{d}} m"),
        showV_f:Cable.template("#v_f", "{{v_f}} m/s"),

        setup:function(d3, _plot, init) {
          // TODO: Should check self-depenency?
          _plot(Plot.setup(d3));
        },

        display:function(d3, plot, g, theta, v, y_0, _region) {
          // TODO: this test ought to be default functionality.
          if (
            plot() != undefined &&
            g() != undefined &&
            theta() != undefined &&
            v() != undefined &&
            y_0() != undefined
          ) {
            _region(
              Plot.update(
                d3,
                plot(),
                _region(),
                g(),
                theta(),
                v(),
                y_0()
              )
            );
          }
        }
      });
    </script>
  </body>
</html>
